import OpenAI from 'openai';
import { Octokit } from '@octokit/rest';
import { execSync } from 'child_process';
import fs from 'fs-extra';
import 'dotenv/config';

/// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Initialize Octokit client
const octokit = new Octokit();

const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
const ISSUE_NUMBER = process.env.ISSUE_NUMBER;
const GIT_EMAIL = process.env.GIT_EMAIL
const GIT_NAME = process.env.GIT_NAME

async function fetchIssueDetails() {
  const { data } = await octokit.issues.get({
    owner,
    repo,
    issue_number: ISSUE_NUMBER,
  });
  return `${data.title}\n\n${data.body}`;
}

async function modifyCodeWithChatGPT(issueDetails, repoSummary) {
  const response = await openai.chat.completions.create({
    model: 'gpt-4o',
    messages: [
      { role: 'system', content: 'You are an expert AI developer specialized in improving existing code based on user requests. Your job is to take a GitHub issue created by a user, verify if the problem actually occurs and provide full code for all modified files that will fix the issue. Respond strictly in JSON format with no additional explanation. If a code change is needed, respond with:{"filename": "<relative-path-to-file>","content": "<full file content>"} If multiple files need changes, return an array:[{ "filename": "<file1>", "content": "<new content>" },{ "filename": "<file2>", "content": "<new content>" }] Do not include any explanations or comments. Only return valid JSON without any formatting markers.' },
      { role: 'user', content: `### Issue Details:\n${issueDetails}\n\n### GitHub Repository:\n${repoSummary}\n\n### Modify the code to fix the issue.` },
    ],
  });

  return response.choices[0].message.content.trim();
}

async function createPullRequest() {
  const branchName = `auto-fix-issue-${ISSUE_NUMBER}`;
  execSync(`git config user.email ${GIT_EMAIL}`);
  execSync(`git config user.name ${GIT_NAME}`);
  execSync(`git checkout -b ${branchName}`);
  execSync('git add .');
  execSync('git commit -m "Auto-fix by ChatGPT"');
  execSync(`git push origin ${branchName}`);

  await octokit.pulls.create({
    owner,
    repo,
    title: `Auto-fix: Issue #${ISSUE_NUMBER}`,
    head: branchName,
    base: 'main',
    body: `This PR was automatically generated by ChatGPT to address issue #${ISSUE_NUMBER}.`,
  });
}

(async function run() {
  try {
    const issueDetails = await fetchIssueDetails();
    //const allFiles = await fetchRepoFiles();

    //console.log('Fetching repo content...');
    //const repoSummary = await generateRepoSummary(allFiles); // Fetch and summarize the entire repo

    console.log('Sending repo summary to ChatGPT...');
    const aiResponse = await modifyCodeWithChatGPT(issueDetails, 'https://github.com/mic-pie/hello-world-react-website');
	console.log('aiResponse: ' + aiResponse );
	
	const aiCleanResponse = aiResponse.replace(/^```json\s*|\s*```$/g, '');
	console.log('aiCleanResponse: ' + aiCleanResponse );
	
    // Write the modified code back to files
	console.log('Parsing response to JSON');
	let filesToUpdate = [];
	try {
	  filesToUpdate = JSON.parse(aiCleanResponse);
	} catch (error) {
	  console.error("Error parsing AI response:", error);
	  return;
	}

	if (!Array.isArray(filesToUpdate)) {
	  console.error("AI response is not a valid file array:", filesToUpdate);
	  return;
	}

	console.log('Updating files...');
	filesToUpdate.forEach(({ filename, content }) => {
	  console.log(`Updating file: ${filename}`);
	  fs.writeFileSync(filename, content, "utf-8");
	});
	console.log('Files updated');

    // const modifiedFiles = aiResponse.split('\n\n');
    // for (const modifiedFile of modifiedFiles) {
	  // const [filePath, ...codeLines] = modifiedFile.split(':');
      // const code = codeLines.join(':').trim();
      // if (code) {
        // fs.writeFileSync(filePath, code, 'utf-8');
      // }
    // }

    await createPullRequest();
  } catch (error) {
    console.error('Error during automation:', error);
  }
})();
